import { getSession, setPaired, setRepo, setPending, resetPending } from './sessions.js';
import { readFile, listRecentWorkflowRuns } from '../github/repo.js';
import { createBranchFromDefault, upsertFile, openPullRequest } from '../github/pr.js';
import { proposePatch } from '../llm/patcher.js';
import { createProgressContract } from './progressContract.js';

function helpText() {
  return [
    '*Janitor Commands (single-admin)*',
    '',
    '`PAIR`',
    '`USE REPO owner/name`',
    '`STATUS`',
    '`CI`',
    '`FILE path/to/file`',
    '`FIX path/to/file | your goal text`',
    '`APPROVE:PR branch-name`',
    '',
    'Notes:',
    '- Each chat is locked to one repo.',
    '- PR-only writes. No direct main pushes.'
  ].join('\n');
}

export async function handleCommand(msg, text, sendMessage, editMessage) {
  const chatId = msg.chat.id;
  const session = getSession(chatId);

  // First-time guidance
  if (text.toUpperCase() === 'HELP') {
    return sendMessage(chatId, helpText());
  }

  // Pairing gate
  if (!session.paired) {
    if (text.toUpperCase() === 'PAIR') {
      setPaired(chatId, true);
      return sendMessage(chatId, 'âœ… Paired. Next: `USE REPO ICholding/your-repo`');
    }
    return sendMessage(chatId, 'ğŸ” Pairing required. Reply with: `PAIR`');
  }

  // Repo bind gate
  if (!session.repo) {
    const m = text.match(/^USE\s+REPO\s+([A-Za-z0-9_.-]+)\/([A-Za-z0-9_.-]+)$/i);
    if (m) {
      const owner = m[1];
      const name = m[2];
      setRepo(chatId, owner, name);
      return sendMessage(chatId, `âœ… Repo locked to *${owner}/${name}*\nNow run: \`STATUS\` or \`CI\``);
    }
    return sendMessage(chatId, 'ğŸ“Œ Repo not set. Use: `USE REPO ICholding/your-repo`');
  }

  const { owner, name: repo } = session.repo;

  // STATUS
  if (text.toUpperCase() === 'STATUS') {
    const pending = session.pending ? `\nğŸ§¾ Pending PR: \`${session.pending.branch}\` (awaiting approval)` : '';
    return sendMessage(chatId, `âœ… Scoped Repo: *${owner}/${repo}*\nMode: PR-only\nPairing: ON${pending}`);
  }

  // CI (recent workflow runs)
  if (text.toUpperCase() === 'CI') {
    const runs = await listRecentWorkflowRuns(owner, repo);
    if (!runs.length) return sendMessage(chatId, 'No recent workflow runs found.');
    const lines = runs.map(r => {
      const status = `${r.status}/${r.conclusion || 'â€”'}`;
      return `- ${status} â€” ${r.name} â€” ${r.html_url}`;
    });
    return sendMessage(chatId, `*Recent CI Runs*\n${lines.join('\n')}`);
  }

  // FILE read
  {
    const m = text.match(/^FILE\s+(.+)$/i);
    if (m) {
      const path = m[1].trim();
      const { content } = await readFile(owner, repo, path);
      // Telegram message size limit: keep it short
      const clipped = content.length > 3500 ? content.slice(0, 3500) + '\nâ€¦(clipped)' : content;
      return sendMessage(chatId, `*${path}*\n\`\`\`\n${clipped}\n\`\`\``);
    }
  }

  // FIX
  {
    // Format: FIX path/to/file | goal text
    const m = text.match(/^FIX\s+(.+?)\s*\|\s*(.+)$/i);
    if (m) {
      const path = m[1].trim();
      const goal = m[2].trim();

      const { content: currentContent } = await readFile(owner, repo, path);

      await sendMessage(chatId, `ğŸ§¹ Generating patch plan for *${path}*â€¦`);

      const proposal = await proposePatch({
        owner,
        repo,
        path,
        currentContent,
        goal
      });

      // Prepare pending PR payload (no write yet)
      const branch = `janitor-${Date.now()}`;
      const title = proposal.summary || `Janitor: ${goal}`;
      const body = [
        'Automated PR generated by Software Janitor (single-admin).',
        '',
        `Goal: ${goal}`,
        '',
        'Changes:',
        ...(proposal.changes || []).map(c => `- ${c.path}: ${c.message}`)
      ].join('\n');

      // Sanity: ensure repo stays scoped
      const changes = proposal.changes.map(c => ({
        path: c.path,
        message: c.message || `Update ${c.path}`,
        content: c.content
      }));

      setPending(chatId, { branch, title, body, changes });

      const summaryLines = (proposal.changes || []).map(c => `- \`${c.path}\` â€” ${c.message}`);
      return sendMessage(
        chatId,
        [
          '*âœ… Patch proposal ready (no changes applied yet).*',
          `Repo: *${owner}/${repo}*`,
          `Branch: \`${branch}\``,
          '',
          '*Planned changes:*',
          ...summaryLines,
          '',
          'To create a PR, reply:',
          `\`APPROVE:PR ${branch}\``
        ].join('\n')
      );
    }
  }

  // APPROVE:PR
  {
    const m = text.match(/^APPROVE:PR\s+([A-Za-z0-9_.-]+)$/i);
    if (m) {
      const branch = m[1].trim();
      if (!session.pending) return sendMessage(chatId, 'No pending PR. Run `FIX path | goal` first.');
      if (session.pending.branch !== branch) {
        return sendMessage(chatId, `Pending branch is \`${session.pending.branch}\`. Approve with that exact branch name.`);
      }

      const pending = session.pending;
      await sendMessage(chatId, `ğŸŸ¦ Creating branch \`${branch}\` from defaultâ€¦`);
      await createBranchFromDefault(owner, repo, branch);

      for (const ch of pending.changes) {
        await sendMessage(chatId, `ğŸ“ Updating \`${ch.path}\`â€¦`);
        await upsertFile(owner, repo, ch.path, ch.content, ch.message, branch);
      }

      await sendMessage(chatId, 'ğŸ” Opening PRâ€¦');
      const prUrl = await openPullRequest(owner, repo, pending.title, pending.body, branch);

      resetPending(chatId);
      return sendMessage(chatId, `âœ… PR opened:\n${prUrl}`);
    }
  }

  // Reset pairing (optional)
  if (text.toUpperCase() === 'UNPAIR') {
    setPaired(chatId, false);
    resetPending(chatId);
    return sendMessage(chatId, 'ğŸ”’ Unpaired. Reply `PAIR` to re-enable this chat.');
  }

  return sendMessage(chatId, `Unknown command.\n\n${helpText()}`);
}
